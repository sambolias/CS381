<!DOCTYPE html>

<html>
<!--
  blast.html
  Glenn G. Chappell
  8 Nov 2017

  For CS 381 Fall 2017
  Billboarding & Blending Demo

  Requires gl-matrix-min.js, quoll.js
-->

<!-- ************************************************************** -->
<!-- * Core HTML                                                  * -->
<!-- ************************************************************** -->

<head>
<meta charset="utf-8">
<title>Blast</title>
</head>
<body onload="appMain('can1')"
  style="overflow: hidden; margin: 0; padding: 0;">
<table style="position: absolute; left: 20px; top: 10px; spacing: 20pt;
  color: #6666ff">
<tr>
<td style="padding: 5pt">P</td>
<td style="padding: 5pt">Pause/unpause</td>
</tr>
<tr>
<td style="padding: 5pt">Space</td>
<td style="padding: 5pt">Restart explosion</td>
</tr>
<tr>
<td style="padding: 5pt">W A S D</td>
<td style="padding: 5pt">Move camera up, left, down, right</td>
</tr>
<tr>
<td style="padding: 5pt">Z</td>
<td style="padding: 5pt">Reset camera position</td>
</tr>
<tr>
<td style="padding: 5pt">B</td>
<td style="padding: 5pt">Change kind of billboarding</td>
</tr>
<tr>
<td style="padding: 5pt">L</td>
<td style="padding: 5pt">Toggle blending</td>
</tr>
</table>
<canvas id="can1" width="500" height="400"
    style="display: block; margin: 0; padding: 0;"></canvas>
<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript" src="quoll.js"></script>

<!-- ************************************************************** -->
<!-- * GLSL Shaders                                               * -->
<!-- ************************************************************** -->

<script id="vshader1" type="x-shader/x-vertex">
// Vertex Shader #1

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;

attribute vec4 vertex_attr;
attribute vec4 texcoord_attr;

varying vec2 texcoord_var;


void main()
{
    // Compute texture coordinates
    vec3 texcoord = texcoord_attr.stp / texcoord_attr.q;
    texcoord_var = texcoord.st;

    // Compute vertex position
    gl_Position = projectionMatrix * modelViewMatrix * vertex_attr;

}
</script>
<script id="fshader1" type="x-shader/x-fragment">
// Fragment Shader #1

#ifdef GL_ES
precision mediump float;
#endif

varying vec2 texcoord_var;

uniform sampler2D tex0;     // Our texture


void main()
{
    // Get color from texture
    vec4 texcolor = texture2D(tex0, texcoord_var);

    // Send color to framebuffer
    gl_FragColor = texcolor;
}
</script>

<!-- END GLSL Shaders -->

<!-- ************************************************************** -->
<!-- * JavaScript Application                                     * -->
<!-- ************************************************************** -->

<script type="text/javascript">
// Global variables

// WebGL General
var gl;                 // WebGL rendering context

// Shaders
var shaderprog1;        // Shader program object

// Objects
var resetingcam;        // Boolean: in middle of camera pos reset?
var blendflag;          // Boolean: do blending?
var bbkind;             // 0: no billboarding, 1: cylindrical,
                        //  2: spherical
var running;            // True if simulation running
var sideang;            // Side-to-side rotation for camera (rad)
var sideang_start = 0.; // Initial value for above
var upang;              // Upward rotation for camers (rad)
var upang_start = Math.PI/180. * 8.;
                        // Initial value for above
var NUM_OBJECTS = 500;  // Number of objects
var velfact = 7.;       // Multiplier for velocity
var gravity = 3.;       // Gravity accel (world coords/sec^2)

var locs;               // Object locaations (world coords)
                        //  Each item is glMatrix vec3
var vels;               // Object velocities (world coords/sec)
                        //  Each item if glMatrix vec3

// Textures
var tex0;               // Texture object #0
var img0;               // Image for texture #0


// initObjects
// Initialize locs & vels arrays.
function initObjects()
{
    locs = new Array();
    vels = new Array();
    for (var i = 0; i < NUM_OBJECTS; ++i)
    {
        var loc;  // Location of this object  
        var vel;  // Velocity of this object

        // All objects start @ origin
        loc = vec3.fromValues(0., 0., 0.);

        // Velocity <- random vector of length <= 1 w/ nonneg y coord
        do
        {
            vel = vec3.fromValues(
                Math.random()*2.-1.,   // Random in [-1., 1.]
                Math.random(),         // Random in [ 0., 1.]
                Math.random()*2.-1.);  // Random in [-1., 1.]
        }
        while (vel[0]*vel[0] + vel[1]*vel[1] + vel[2]*vel[2] > 1.);

        // Scale velocity by velfact
        vel[0] *= velfact;
        vel[1] *= velfact;
        vel[2] *= velfact;

        // Add location & velocity to list
        locs.push(loc);
        vels.push(vel);
    }
}


// makeTextures
// Make whatever textures need to be made, in global texture objects
function makeTextures()
{
    tex0 = gl.createTexture();

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tex0);

    // Make the image
    var TEX_DIM = 256;
    img0 = new Uint8Array(TEX_DIM * TEX_DIM * 4)
    var k = 4.0;
    for (var i = 0; i < TEX_DIM; ++i)
    {
        var x = i/(TEX_DIM-1) * 2. - 1.;
        for (var j = 0; j < TEX_DIM; ++j)
        {
            var y = j/(TEX_DIM-1) * 2. - 1.;
            var distsq = x*x + y*y;
            var alpha = 0.;
            if (distsq < 1.)
                alpha = (Math.exp(-k*distsq) - Math.exp(-k))
                    / (1.-Math.exp(-k));
            img0[i*TEX_DIM*4+j*4+0] = 255;
            img0[i*TEX_DIM*4+j*4+1] = 255;
            img0[i*TEX_DIM*4+j*4+2] = 240;
            img0[i*TEX_DIM*4+j*4+3] = alpha * 255;
        }
    }

    var level = 0;
    var internalformat = gl.RGBA;
    var width = TEX_DIM;
    var height = TEX_DIM;
    var border = 0;
    var srcformat = gl.RGBA;
    var srctype = gl.UNSIGNED_BYTE;
    var pixels = img0;
    gl.texImage2D(gl.TEXTURE_2D, level, internalformat,
                  width, height, border, srcformat, srctype,
                  pixels);
    gl.generateMipmap(gl.TEXTURE_2D);

    gl.texParameteri(gl.TEXTURE_2D,
        gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,
        gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,
        gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,
        gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
}


// appMain
// Our Main program.
// Given ID of canvas.
function appMain(canvasid)
{
    // Initialize quoll.js & WebGL
    gl = quollInit(canvasid);
    if (!gl) return;  // Could not intialize; exit

    // Shaders
    shaderprog1 = makeProgramObjectFromIds(gl, 'vshader1', 'fshader1');
    if (!shaderprog1) return;  // Could not compile shaders; exit

    // Register callbacks with quoll.js
    registerDisplay(myDisplay);
    registerIdle(myIdle);
    registerReshape(myReshape);
    canvasFullWindow(true);  // Make canvas fill the window

    // Set up other event handlers
    document.addEventListener('keypress', myKeyboard, false);

    // Objects
    resetingcam = false;
    blendflag = true;
    bbkind = 2;
    running = true;
    sideang = sideang_start;
    upang = upang_start;
    initObjects();

    // GL States
    //gl.enable(gl.DEPTH_TEST);

    // Textures
    makeTextures();
    gl.useProgram(shaderprog1);
    var loc = gl.getUniformLocation(shaderprog1, 'tex0');
    if (loc != -1)
    {
        gl.uniform1i(loc, 0);
    }    
}


// doBillboard
// Do billboarding using current model/view matrix (gl.mvMatrix).
// Does rotation that points <0.,0.,1.> at camera. bb is kind of
// billboarding: 0 for none, 1 for cylindrial, 2 for spherical.
function doBillboard(bb)
{
    if (bb == 0)
        return;

    var c = whereAmI(gl.mvMatrix);

    if (bb == 1)
    {
        c[1] = 0.;
    }

    var dot = c[2] / Math.sqrt(c[0]*c[0] + c[1]*c[1] + c[2]*c[2]);
    var ang = Math.acos(dot);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix,
        ang, [-c[1],c[0],0.]);
}


// drawObjects
// Our object drawing function.
function drawObjects()
{
    // Loop thru anumated objects
    for (var i = 0; i < NUM_OBJECTS; ++i)
    {
        pushMvMatrix(gl);

        // Move to proper position
        mat4.translate(gl.mvMatrix, gl.mvMatrix,
            [locs[i][0], locs[i][1], locs[i][2]]);

        // Billboarding
        doBillboard(bbkind);

        // Draw it
        drawSquare(gl, 0.8, 0.6, 0.4);

        popMvMatrix(gl);
    }
}


// myDisplay
// The display function.
function myDisplay()
{
    gl.useProgram(shaderprog1);

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Camera transformation
    mat4.identity(gl.mvMatrix);
    mat4.translate(gl.mvMatrix, gl.mvMatrix,
        [0., 0., -15.]);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix,
        upang, [1., 0., 0.]);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix,
        sideang, [0., 1., 0.]);

    // Blending?
    if (blendflag)
    {
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    }
    else
    {
        gl.disable(gl.BLEND);
    }

    // Draw scene
    drawObjects();

    gl.flush();
}


// myIdle
// The idle function.
function myIdle()
{
    var elapsedtime = getElapsedTime(0.1);

    // Animate objects?
    if (running)
    {
        // Loop thru animated objects
        for (var i = 0; i < NUM_OBJECTS; ++i)
        {
            // Modify velocity with gravity
            vels[i][1] -= gravity * elapsedtime;

            // Modify position with velocity
            locs[i][0] += vels[i][0] * elapsedtime;
            locs[i][1] += vels[i][1] * elapsedtime;
            locs[i][2] += vels[i][2] * elapsedtime;

            // Bounce
            if (locs[i][1] < 0.)  // Below ground?
            {
                // Bounce object up & remove potential energy
                var vy = vels[i][1];
                var potential = vy*vy-2.*gravity*(-2.*locs[i][1]);
                if (potential < 0.)
                {
                    vels[i][1] = 0.;
                    locs[i][1] = 0.;
                }
                else
                {
                    vels[i][1] = Math.sqrt(potential);
                    locs[i][1] = -locs[i][1];
                }

                // Damp velocity
                var damp = 0.6;
                vels[i][0] *= damp;
                vels[i][1] *= damp;
                vels[i][2] *= damp;
            }
        }
        postRedisplay();
    }

    // Reset camera position?
    if (resetingcam)
    {
        var minmove = Math.PI/180. * 0.001;  // Min move angle (rad)
        var speedfact = 7.0;                 // Base angle speed =
                                             //  this * angle diff
        var maxspeed = Math.PI/180. * 100.;  // Max ang speed (rad/sec)

        while (sideang > Math.PI/180. * 180.)
           sideang -= Math.PI/180. * 360.;
        while (sideang < Math.PI/180. * -180.)
           sideang += Math.PI/180. * 360.;

        // Compute diffs between current angles, start angles
        var sidediff = sideang_start - sideang;
        var sidesign = (sidediff < 0.) ? -1. : 1.;

        var updiff = upang_start - upang;
        var upsign = (updiff < 0.) ? -1. : 1.;

        // If move is small, just do it, and we are done
        if (sidediff*sidesign < minmove && updiff*upsign < minmove)
        {
            sideang = sideang_start;
            upang = upang_start;
            resetingcam = false;
        }
        else
        {
            // Compute base angle speeds
            var sidespeed = speedfact * sidediff * sidesign;
            var upspeed = speedfact * updiff * upsign;

            // If speed too high, reduce both in proportion
            if (sidespeed > maxspeed || upspeed > maxspeed)
            {
                if (sidespeed > upspeed)
                {
                    upspeed *= maxspeed / sidespeed;
                    sidespeed = maxspeed;
                }
                else
                {
                    sidespeed *= maxspeed / upspeed;
                    upspeed = maxspeed;
                }
            }

            // Set the new camera angles
            sideang += sidespeed * sidesign * elapsedtime;
            upang += upspeed * upsign * elapsedtime;
        }
        postRedisplay();
    }
}


// myReshape
// The reshape callback function. Called by quoll.js.
function myReshape(w, h)
{
    // Set up viewport
    gl.viewport(0, 0, w, h);

    // Set up projection
    mat4.perspective(gl.pMatrix,
                     Math.PI/180. * 60.,  // y field-of-view angle
                     w/h,                 // Viewport aspect ratio
                     0.1, 100.);          // Near & far distances
}


function myKeyboard(evt)
{
    var ch = keyFromEvent(evt);

    // Note: Keys like [Esc] may be handled inconsistently between
    // browsers. Alas! So we only deal with printable ASCII here.

    switch (ch)
    {
    case 'p':  // P: Pause/unpause
    case 'P':
        running = !running;
        break;
    case ' ':  // Space: Restart explosion
        initObjects();
        running = true;
        postRedisplay();
        break;
    case 'b':  // B: Cycle billboarding type forward
        bbkind = (bbkind+1)%3;
        postRedisplay();
        break;
    case 'B':  // B: Cycle billboarding type backward
        bbkind = (bbkind+3-1)%3;
        postRedisplay();
        break;
    case 'l':  // L: Toggle blending
    case 'L':
        blendflag = !blendflag;
        break;
    case 'w':  // W: Move camera up
    case 'W':
        upang += Math.PI/180. * 2.;
        if (upang > Math.PI/2.)
            upang = Math.PI/2.;
        postRedisplay();
        break;
    case 'a':  // A: Move camera left
    case 'A':
        sideang += Math.PI/180. * 2.;
        postRedisplay();
        break;
    case 's':  // S: Move camera down
    case 'S':
        upang -= Math.PI/180. * 2.;
        if (upang < 0.)
            upang = 0.;
        postRedisplay();
        break;
    case 'd':  // D: Move camera right
    case 'D':
        sideang -= Math.PI/180. * 2.;
        postRedisplay();
        break;
    case 'z':  // Z: Reset camera pos
    case 'Z':
        resetingcam = true;
        break;
    }
}
</script>
</body>
</html>

